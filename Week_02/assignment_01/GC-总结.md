# GcDetailAnalysis
环境：MacOs 4c8g

1.Serial GC:初始堆大小128M，最大堆大小2G。平均生成对象次数8500次。其中某次，共进行23次gc，其中包含Full GC4次。随着年轻代逐渐增大，young gc时间越来越长，最大为59ms，最小为6ms；old gc时间也随之增大，从17ms增长至55ms。由此可见，串行gc虽然gc效率高，但是gc停顿时间较长。

2.并行GC:初始堆大小128M，最大堆大小2G。平均生成对象次数11000次。其中某次，共进行14次GC，Full GC4次。young gc时间跨度为5ms到87ms，Full gc为16ms到55ms。和串行GC相比，GC次数减少，总停顿时间也明显减少，可以看出并行GC更适合多核服务器，GC期间所有CPU内核都在清理垃圾。

3.CMS GC：初始堆大小128M，最大堆大小2G。平均生成对象8200次，young区gc时间平均为8ms，没有进行full gc。可以看出，CMS gc大幅减少了gc停顿，降低了系统延迟，但是牺牲了吞吐量。

4.G1 GC：初始堆大小128M，最大堆大小2G。平均生成对象次数6000次。通过日志可以看出，发生的基本都是年轻代转移暂停，初始时长在4ms左右，随着young区大小不断调整，时长增长至36ms。此外，仅有一次大对象分配失败导致gc。可以看出G1明显是有选择的进行了垃圾回收区域的清理，避免了Full GC。

# Gateway-server压测分析
环境：Windows 4c8g

压测命令：sb -u http://localhost:8088/api/hello -c 20 -N 60

1.串行GC：RPS：2509，响应200的请求为153147个，最长响应时间304ms，99%的请求平均响应时间低于6ms，99.9%的请求平均响应时间低于14ms

2.并行：RPS：2325，响应200的请求为141936个，最长响应时间287ms，99%的请求平均响应时间低于7ms，99.9%的请求平均响应时间低于14ms

3.G1 GC：RPS：2023，响应200的请求为123700个，最长响应时间305ms，99%的请求平均响应时间低于8ms，99.9%的请求平均响应时间低于15ms

4.CMS GC：RPS：1685，响应200的请求为103086个，最长响应时间415ms，99%的请求平均响应时间低于32ms，99.9%的请求平均响应时间低于103ms

通过观察以上数据可知，当前环境和参数下，并行GC延迟更低，串行GC吞吐量最大，性能最差的是CMS GC。由于当前默认最大堆2G，因此G1 GC没有发挥出实力，适用于8G或者更大的堆内存情况。比较串行GC和并行GC，并行GC由于停顿时间更短，最长响应时间要优于串行GC。猜测由于环境参数较低，串行GC简单粗暴，适合发挥，因此吞吐量最高（请助教老师帮忙看下这里，有点搞不明白啦）。CMS GC则为了减少老年代垃圾收集时的卡顿牺牲了吞吐量，也不适应于当前核数较少的环境。